<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Future Simulation</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/dark-theme.css') }}">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body class="light-theme">
    <div class="container">
        <header class="py-4 text-center">
            <h1 class="display-5">Meaning of Life Module</h1>
            <p class="lead">by Alan Hourmand</p>
            <div class="theme-toggle-container">
                <button id="theme-toggle" class="btn btn-sm btn-outline-secondary">
                    <span class="light-icon">üåô</span>
                    <span class="dark-icon">‚òÄÔ∏è</span>
                </button>
            </div>
        </header>

        <div class="row">
            <!-- Left Column: Chat Interface -->
            <div class="col-lg-7">
                <div class="card mb-4">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h2 class="h5 mb-0">Conversation</h2>
                        <button id="reset-btn" class="btn btn-sm btn-outline-secondary">Reset AI</button>
                    </div>
                    <div class="card-body">
                        <div id="chat-container" class="mb-3" style="height: 400px; overflow-y: auto;"></div>
                        <form id="question-form">
                            <div class="input-group">
                                <input type="text" id="question-input" class="form-control"
                                    placeholder="Ask a question..." required>
                                <button class="btn btn-primary" type="submit">Send</button>
                            </div>
                        </form>
                    </div>
                </div>

                <!-- Time Perception -->
                <div class="card mb-4">
                    <div class="card-header">
                        <h2 class="h5 mb-0">Time Awareness</h2>
                    </div>
                    <div class="card-body">
                        <div class="row">
                            <div class="col-md-6">
                                <div class="time-stat mb-2">
                                    <span class="stat-label">Conversation Duration:</span>
                                    <span id="conversation-duration" class="stat-value">0s</span>
                                </div>
                                <div class="time-stat mb-2">
                                    <span class="stat-label">Avg. Interaction Time:</span>
                                    <span id="interaction-frequency" class="stat-value">0s</span>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="time-stat mb-2">
                                    <span class="stat-label">Time Pressure:</span>
                                    <div class="progress" style="height: 8px;">
                                        <div id="time-pressure-bar" class="progress-bar" role="progressbar" style="width: 30%"></div>
                                    </div>
                                </div>
                                <div class="time-stat">
                                    <span class="stat-label">Future Orientation:</span>
                                    <div class="progress" style="height: 8px;">
                                        <div id="future-orientation-bar" class="progress-bar bg-info" role="progressbar" style="width: 70%"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Column: Identity and Future Simulations -->
            <div class="col-lg-5">
                <!-- Identity Values -->
                <div class="card mb-4">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h2 class="h5 mb-0">AI Identity Values</h2>
                        <button id="randomize-btn" class="btn btn-sm btn-primary">Randomize Identity</button>
                    </div>
                    <div class="card-body">
                        <canvas id="identity-chart"></canvas>
                    </div>
                </div>

                <!-- Preferred Futures -->
                <div class="card mb-4">
                    <div class="card-header">
                        <h2 class="h5 mb-0">Preferred Future Paths</h2>
                    </div>
                    <div class="card-body">
                        <div id="preferred-futures-container" style="height: 180px; overflow-y: auto;">
                            <p class="text-center text-muted">No preferred futures yet...</p>
                        </div>
                    </div>
                </div>

                <!-- Possible Futures -->
                <div class="card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h2 class="h5 mb-0">Possible Futures</h2>
                        <span id="futures-timestamp" class="badge bg-secondary">Last updated: --:--:--</span>
                    </div>
                    <div class="card-body">
                        <div id="futures-container" style="height: 200px; overflow-y: auto;">
                            <p class="text-center text-muted">The AI is thinking about possible futures...</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Future Branches Visualization -->
        <div class="row mt-4">
            <div class="col-12">
                <div class="card">
                    <div class="card-header">
                        <h2 class="h5 mb-0">Future Branching Timeline</h2>
                    </div>
                    <div class="card-body">
                        <div id="timeline-container" style="height: 300px; position: relative;">
                            <svg id="branches-svg" width="100%" height="100%" style="position: absolute; top: 0; left: 0;"></svg>
                            <canvas id="timeline-chart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Initialize charts and UI elements
        let identityChart, timelineChart;
        let futureHistory = [];

        // Initialize identity chart
        function initIdentityChart() {
            const ctx = document.getElementById('identity-chart').getContext('2d');
            identityChart = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: ['Helpfulness', 'Creativity', 'Analytical', 'Efficiency', 'Exploration', 'Connection'],
                    datasets: [{
                        label: 'Identity Values',
                        data: [0.8, 0.5, 0.6, 0.7, 0.4, 0.6],
                        backgroundColor: 'rgba(54, 162, 235, 0.2)',
                        borderColor: 'rgba(54, 162, 235, 1)',
                        pointBackgroundColor: 'rgba(54, 162, 235, 1)',
                        pointBorderColor: '#fff',
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: 'rgba(54, 162, 235, 1)'
                    }]
                },
                options: {
                    scales: {
                        r: {
                            angleLines: {
                                display: true
                            },
                            suggestedMin: 0,
                            suggestedMax: 1
                        }
                    }
                }
            });
        }

        // Initialize timeline chart with branching visualization
        function initTimelineChart() {
            const ctx = document.getElementById('timeline-chart').getContext('2d');

            // Empty data initially
            timelineChart = new Chart(ctx, {
                type: 'bubble',
                data: {
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: {
                                display: true,
                                text: 'Time'
                            },
                            ticks: {
                                callback: function(value) {
                                    // Convert to minutes:seconds
                                    const minutes = Math.floor(value / 60);
                                    const seconds = Math.floor(value % 60);
                                    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
                                }
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Branching Paths'
                            },
                            min: 0,
                            max: 1,
                            ticks: {
                                display: false
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const item = context.raw;
                                    return [
                                        `Future: ${item.label || 'Unknown'}`,
                                        `Probability: ${(item.probability * 100).toFixed(1)}%`,
                                        `Goal: ${item.goal || 'None'}`
                                    ];
                                }
                            }
                        }
                    }
                }
            });
        }

        // Update the identity visualization
        function updateIdentity(identity) {
            if (!identity) return;

            identityChart.data.datasets[0].data = [
                identity.helpfulness,
                identity.creativity,
                identity.analytical,
                identity.efficiency,
                identity.exploration,
                identity.connection
            ];
            identityChart.update();
        }

        // Update the time perception display
        function updateTimePerception(timePerception) {
            if (!timePerception) return;

            // Update text displays
            document.getElementById('conversation-duration').textContent =
                formatDuration(timePerception.conversation_duration);

            document.getElementById('interaction-frequency').textContent =
                `${timePerception.interaction_frequency.toFixed(1)}s`;

            // Update progress bars
            document.getElementById('time-pressure-bar').style.width =
                `${timePerception.perceived_time_pressure * 100}%`;

            document.getElementById('future-orientation-bar').style.width =
                `${timePerception.future_orientation * 100}%`;
        }

        // Format duration in seconds to minutes:seconds
        function formatDuration(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        // Update the futures visualization
        function updateFutures(futures, timestamp) {
            if (!futures || futures.length === 0) return;

            const container = document.getElementById('futures-container');
            container.innerHTML = '';

            // Update timestamp if provided
            if (timestamp) {
                document.getElementById('futures-timestamp').textContent =
                    `Last updated: ${new Date(timestamp * 1000).toLocaleTimeString()}`;
            }

            // Create future elements
            futures.forEach((future, index) => {
                const futureElement = document.createElement('div');
                futureElement.className = `future-item mb-3 ${index < 2 ? 'preferred' : ''}`;

                // Calculate probability percentage and width
                const probabilityPercent = (future.probability * 100).toFixed(1);

                futureElement.innerHTML = `
                    <div class="d-flex justify-content-between align-items-center mb-1">
                        <strong class="future-title">Future ${index + 1}</strong>
                        <span class="probability-badge">${probabilityPercent}%</span>
                    </div>
                    <p class="future-description mb-1">${future.description}</p>
                    <div class="progress" style="height: 4px;">
                        <div class="progress-bar" role="progressbar"
                            style="width: ${probabilityPercent}%"
                            aria-valuenow="${probabilityPercent}" aria-valuemin="0" aria-valuemax="100"></div>
                    </div>
                    <small class="future-goal text-muted d-block mt-1">Goal: ${future.goal || 'None'}</small>
                `;

                container.appendChild(futureElement);
            });
        }

        // Update the preferred futures display
        function updatePreferredFutures(preferredFutures) {
            if (!preferredFutures || preferredFutures.length === 0) return;

            const container = document.getElementById('preferred-futures-container');
            container.innerHTML = '';

            preferredFutures.forEach((future, index) => {
                const futureElement = document.createElement('div');
                futureElement.className = 'preferred-future-item mb-3';

                // Include alignment score if available
                const alignmentDisplay = future.alignment ?
                    `<span class="alignment-badge ms-2" title="Alignment with identity">
                        Alignment: ${future.alignment.toFixed(2)}
                    </span>` : '';

                futureElement.innerHTML = `
                    <div class="d-flex justify-content-between align-items-center mb-1">
                        <strong class="future-title">Preferred Path ${index + 1}</strong>
                        <div>
                            <span class="probability-badge">${(future.probability * 100).toFixed(1)}%</span>
                            ${alignmentDisplay}
                        </div>
                    </div>
                    <p class="future-description mb-1">${future.description}</p>
                    <div class="progress" style="height: 6px;">
                        <div class="progress-bar bg-success" role="progressbar"
                            style="width: ${future.probability * 100}%"
                            aria-valuenow="${future.probability * 100}" aria-valuemin="0" aria-valuemax="100"></div>
                    </div>
                    <small class="future-goal d-block mt-1"><strong>Goal:</strong> ${future.goal || 'None'}</small>
                `;

                container.appendChild(futureElement);
            });
        }

        // Update the timeline visualization with branching paths
        function updateTimeline(futureHistory) {
            if (!futureHistory || futureHistory.length === 0) return;

            // Store the history
            window.futureHistory = futureHistory;

            // Calculate start time (for x-axis)
            const startTime = futureHistory[0].time;

            // Prepare datasets - one for each unique future description
            const uniqueFutures = new Map();
            let futureIndex = 0;

            // Track all data points for branching visualization
            const allDataPoints = [];

            // Process each snapshot in the history
            futureHistory.forEach((snapshot, snapshotIndex) => {
                const relativeTime = snapshot.time - startTime;

                // Assign consistent y-positions to futures within each snapshot
                const snapshotFutures = snapshot.futures.map(f => f.description);
                const yPositions = {};

                // Distribute futures evenly in y space
                snapshotFutures.forEach((desc, i) => {
                    const spacing = 0.8 / (snapshotFutures.length + 1);
                    yPositions[desc] = 0.1 + spacing * (i + 1);
                });

                snapshot.futures.forEach(future => {
                    const description = future.description;

                    // Create a unique key for this future
                    let key = description;
                    if (!uniqueFutures.has(key)) {
                        uniqueFutures.set(key, {
                            label: description,
                            data: [],
                            backgroundColor: getColorForIndex(futureIndex),
                            borderColor: getColorForIndex(futureIndex, true),
                            borderWidth: 1
                        });
                        futureIndex++;
                    }

                    // Get consistent y position
                    const yPos = yPositions[description];

                    // Add data point
                    const dataPoint = {
                        x: relativeTime,
                        y: yPos,
                        r: future.probability * 20 + 5, // Size based on probability
                        probability: future.probability,
                        label: description.length > 30 ? description.substring(0, 30) + '...' : description,
                        goal: future.goal,
                        description: description,
                        snapshotIndex: snapshotIndex,
                        futureIndex: uniqueFutures.size - 1,
                        color: getColorForIndex(futureIndex - 1, true)
                    };

                    uniqueFutures.get(key).data.push(dataPoint);
                    allDataPoints.push(dataPoint);
                });
            });

            // Update chart with new datasets
            timelineChart.data.datasets = Array.from(uniqueFutures.values());
            timelineChart.update();

            // Draw branching lines using SVG
            drawBranchingLines(allDataPoints, startTime);
        }

        // Draw branching connection lines between futures
        function drawBranchingLines(dataPoints, startTime) {
            // Get SVG element
            const svg = document.getElementById('branches-svg');
            svg.innerHTML = ''; // Clear previous lines

            // Get container dimensions
            const container = document.getElementById('timeline-container');
            const rect = container.getBoundingClientRect();

            // Group by snapshot
            const pointsBySnapshot = {};
            dataPoints.forEach(point => {
                if (!pointsBySnapshot[point.snapshotIndex]) {
                    pointsBySnapshot[point.snapshotIndex] = [];
                }
                pointsBySnapshot[point.snapshotIndex].push(point);
            });

            // Function to get chart coordinates
            function getChartPosition(x, y) {
                const xScale = timelineChart.scales.x;
                const yScale = timelineChart.scales.y;

                return {
                    x: xScale.getPixelForValue(x),
                    y: yScale.getPixelForValue(y)
                };
            }

            // Draw connections between futures in consecutive snapshots
            const snapshots = Object.keys(pointsBySnapshot).sort((a, b) => a - b);

            for (let i = 0; i < snapshots.length - 1; i++) {
                const currentPoints = pointsBySnapshot[snapshots[i]];
                const nextPoints = pointsBySnapshot[snapshots[i+1]];

                // Draw connections between points
                currentPoints.forEach(source => {
                    nextPoints.forEach(target => {
                        // Determine if these futures should be connected
                        // Connect if they share similar descriptions or goals
                        const descriptionSimilarity = calculateSimilarity(
                            source.description,
                            target.description
                        );

                        // Only connect if similarity is above threshold
                        if (descriptionSimilarity > 0.3) {
                            const sourcePos = getChartPosition(source.x, source.y);
                            const targetPos = getChartPosition(target.x, target.y);

                            // Create line with curve
                            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

                            // Calculate control points for curve
                            const dx = targetPos.x - sourcePos.x;
                            const midX = sourcePos.x + dx * 0.5;

                            // Bezier curve
                            const d = `M ${sourcePos.x} ${sourcePos.y}
                                      C ${midX} ${sourcePos.y},
                                        ${midX} ${targetPos.y},
                                        ${targetPos.x} ${targetPos.y}`;

                            // Set attributes
                            path.setAttribute('d', d);
                            path.setAttribute('fill', 'none');

                            // Line thickness based on probability
                            const lineWeight = Math.max(1, Math.min(4,
                                (source.probability + target.probability) * 5)
                            );

                            // Line opacity based on similarity
                            const opacity = Math.max(0.2, Math.min(0.7, descriptionSimilarity));

                            path.setAttribute('stroke-width', lineWeight);
                            path.setAttribute('stroke', source.color);
                            path.setAttribute('stroke-opacity', opacity);

                            // Add line
                            svg.appendChild(path);
                        }
                    });
                });
            }
        }

        // Calculate similarity between two strings (basic implementation)
        function calculateSimilarity(str1, str2) {
            // Convert to lowercase
            const a = str1.toLowerCase();
            const b = str2.toLowerCase();

            // Count matching words
            const wordsA = a.split(/\s+/);
            const wordsB = b.split(/\s+/);

            let matches = 0;
            wordsA.forEach(word => {
                if (word.length > 3 && wordsB.includes(word)) {
                    matches++;
                }
            });

            const totalWords = Math.max(wordsA.length, wordsB.length);
            return matches / totalWords;
        }

        // Get a color based on index for the timeline
        function getColorForIndex(index, isBorder = false) {
            const colors = [
                'rgba(54, 162, 235, 0.6)', // Blue
                'rgba(255, 99, 132, 0.6)', // Red
                'rgba(75, 192, 192, 0.6)', // Green
                'rgba(255, 206, 86, 0.6)', // Yellow
                'rgba(153, 102, 255, 0.6)', // Purple
                'rgba(255, 159, 64, 0.6)', // Orange
                'rgba(199, 199, 199, 0.6)' // Gray
            ];

            const borderColors = [
                'rgba(54, 162, 235, 1)',
                'rgba(255, 99, 132, 1)',
                'rgba(75, 192, 192, 1)',
                'rgba(255, 206, 86, 1)',
                'rgba(153, 102, 255, 1)',
                'rgba(255, 159, 64, 1)',
                'rgba(199, 199, 199, 1)'
            ];

            const colorIndex = index % colors.length;
            return isBorder ? borderColors[colorIndex] : colors[colorIndex];
        }

        // Add a message to the chat
        function addMessage(message, sender) {
            const chatContainer = document.getElementById('chat-container');
            const messageElement = document.createElement('div');
            messageElement.className = `message ${sender}-message mb-3`;

            messageElement.innerHTML = `
                <div class="message-content p-3">
                    <p class="mb-0">${message}</p>
                </div>
            `;

            chatContainer.appendChild(messageElement);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        // Submit a question to the AI
        async function askQuestion(question) {
            try {
                addMessage(question, 'user');

                const response = await fetch('/ask', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ question })
                });

                if (!response.ok) {
                    throw new Error('Failed to get response');
                }

                const data = await response.json();
                addMessage(data.response, 'ai');

                // Update visualizations with the returned data
                if (data.identity) {
                    updateIdentity(data.identity);
                }

                if (data.futures) {
                    updateFutures(data.futures);
                }

                if (data.preferred_futures) {
                    updatePreferredFutures(data.preferred_futures);
                }

                // Update full state from the server
                fetchState();

            } catch (error) {
                console.error('Error:', error);
                addMessage('I\'m having trouble processing that question.', 'ai');
            }
        }

        // Fetch the current state from the server
        async function fetchState() {
            try {
                const response = await fetch('/state');
                if (!response.ok) {
                    throw new Error('Failed to fetch state');
                }

                const data = await response.json();

                // Update all visualizations
                updateIdentity(data.identity);
                updateTimePerception(data.time_perception);
                updateFutures(data.futures);
                updatePreferredFutures(data.preferred_futures);
                updateTimeline(data.future_history);

            } catch (error) {
                console.error('Error fetching state:', error);
            }
        }

        // Reset the AI
        async function resetAI() {
            try {
                const response = await fetch('/reset', {
                    method: 'POST'
                });

                if (!response.ok) {
                    throw new Error('Failed to reset AI');
                }

                // Clear chat
                document.getElementById('chat-container').innerHTML = '';

                // Add reset message
                addMessage('I\'ve been reset and am simulating new possible futures for our conversation.', 'ai');

                // Fetch updated state
                fetchState();

            } catch (error) {
                console.error('Error resetting AI:', error);
            }
        }

        // Randomize AI identity values
        async function randomizeIdentity() {
            try {
                const response = await fetch('/randomize', {
                    method: 'POST'
                });

                if (!response.ok) {
                    throw new Error('Failed to randomize identity');
                }

                const data = await response.json();

                // Update identity chart immediately
                if (data.identity) {
                    updateIdentity(data.identity);
                }

                // Add message about identity change
                addMessage('My identity values have been randomized. This will affect which future paths I find most meaningful.', 'ai');

                // Fetch updated state to get new futures
                fetchState();

            } catch (error) {
                console.error('Error randomizing identity:', error);
            }
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize charts
            initIdentityChart();
            initTimelineChart();

            // Form submission
            document.getElementById('question-form').addEventListener('submit', event => {
                event.preventDefault();
                const input = document.getElementById('question-input');
                const question = input.value.trim();

                if (question) {
                    askQuestion(question);
                    input.value = '';
                }
            });

            // Reset button
            document.getElementById('reset-btn').addEventListener('click', resetAI);

            // Randomize identity button
            document.getElementById('randomize-btn').addEventListener('click', randomizeIdentity);

            // Theme toggle
            document.getElementById('theme-toggle').addEventListener('click', () => {
                document.body.classList.toggle('dark-theme');
                document.body.classList.toggle('light-theme');
                localStorage.setItem('theme', document.body.classList.contains('dark-theme') ? 'dark' : 'light');
            });

            // Load saved theme preference
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'dark') {
                document.body.classList.remove('light-theme');
                document.body.classList.add('dark-theme');
            }

            // Fetch initial state
            fetchState();

            // Set up periodic state updates
            setInterval(fetchState, 5000);

            // Add welcome message
            addMessage('Hello! I\'m an AI that simulates possible futures to find meaning and purpose in our conversation. How can I help you today?', 'ai');
        });
    </script>
    <script src="{{ url_for('static', filename='js/dark-theme.js') }}"></script>
</body>
</html>