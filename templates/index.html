<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meaning of Life Module</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/dark-theme.css') }}">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body class="light-theme">
    <div class="container">
        <header class="py-4 text-center">
            <h1 class="display-5">Meaning of Life Module</h1>
            <p class="lead">by Alan Hourmand</p>
            <div class="theme-toggle-container">
                <button id="theme-toggle" class="btn btn-sm btn-outline-secondary">
                    <span class="light-icon">üåô</span>
                    <span class="dark-icon">‚òÄÔ∏è</span>
                </button>
            </div>
        </header>

        <div class="row">
            <!-- Left Column: Chat Interface -->
            <div class="col-lg-7">
                <div class="card mb-4">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h2 class="h5 mb-0">Conversation</h2>
                        <button id="reset-btn" class="btn btn-sm btn-outline-secondary">Reset AI</button>
                    </div>
                    <div class="card-body">
                        <div id="chat-container" class="mb-3" style="height: 400px; overflow-y: auto;"></div>
                        <form id="question-form">
                            <div class="input-group">
                                <input type="text" id="question-input" class="form-control"
                                    placeholder="Ask a question..." required>
                                <button class="btn btn-primary" type="submit">Send</button>
                            </div>
                        </form>
                    </div>
                </div>

                <!-- Time Perception -->
                <div class="card mb-4">
                    <div class="card-header">
                        <h2 class="h5 mb-0">Time Perception</h2>
                    </div>
                    <div class="card-body">
                        <div class="mb-2 text-center">
                            <small class="text-muted">Influences how the person prioritizes and responds</small>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <div class="time-stat mb-2">
                                    <span class="stat-label">Conversation Duration:</span>
                                    <span id="conversation-duration" class="stat-value">0s</span>
                                </div>
                                <div class="time-stat mb-2">
                                    <span class="stat-label">Avg. Response Time:</span>
                                    <span id="interaction-frequency" class="stat-value">0s</span>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="time-stat mb-2">
                                    <span class="stat-label">Perceived Time Pressure:</span>
                                    <div class="progress" style="height: 8px;">
                                        <div id="time-pressure-bar" class="progress-bar" role="progressbar" style="width: 30%"></div>
                                    </div>
                                </div>
                                <div class="time-stat">
                                    <span class="stat-label">Future Orientation:</span>
                                    <div class="progress" style="height: 8px;">
                                        <div id="future-orientation-bar" class="progress-bar bg-info" role="progressbar" style="width: 70%"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Column: Identity and Future Simulations -->
            <div class="col-lg-5">
                <!-- Identity Values -->
                <div class="card mb-4">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h2 class="h5 mb-0">Personality Profile</h2>
                        <button id="randomize-btn" class="btn btn-sm btn-primary">Randomize Personality</button>
                    </div>
                    <div class="card-body">
                        <canvas id="identity-chart"></canvas>
                    </div>
                </div>

                <!-- Preferred Futures -->
                <div class="card mb-4">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h2 class="h5 mb-0">Preferred Future Paths</h2>
                        <span class="badge bg-info">Subconscious Influence</span>
                    </div>
                    <div class="card-body">
                        <div id="preferred-futures-container" style="height: 180px; overflow-y: auto;">
                            <p class="text-center text-muted">No preferred futures yet...</p>
                        </div>
                    </div>
                </div>

                <!-- Past Preferred Futures Section -->
                <div class="card mb-4">
                    <div class="card-header">
                        <h2 class="h5 mb-0">Past Preferred Futures</h2>
                    </div>
                    <div class="card-body">
                        <div class="mb-2 text-center">
                            <small class="text-muted">Historical record of highly preferred futures</small>
                        </div>
                        <div id="past-futures-container" style="height: 150px; overflow-y: auto;">
                            <p class="text-center text-muted">No history of preferred futures yet...</p>
                        </div>
                    </div>
                </div>

                <!-- Possible Futures -->
                <div class="card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h2 class="h5 mb-0">Possible Futures</h2>
                        <span id="futures-timestamp" class="badge bg-secondary">Last updated: --:--:--</span>
                    </div>
                    <div class="card-body">
                        <div class="mb-2 text-center">
                            <small class="text-muted">Simulated subconscious future possibilities</small>
                        </div>
                        <div id="futures-container" style="height: 300px; overflow-y: auto;">
                            <p class="text-center text-muted">Simulating possible futures...</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Future Branches Visualization -->
        <div class="row mt-4">
            <div class="col-12">
                <div class="card">
                    <div class="card-header">
                        <h2 class="h5 mb-0">Future Branching Timeline</h2>
                    </div>
                    <div class="card-body">
                        <div class="mb-2 text-center">
                            <small class="text-muted">Visual representation of subconscious future simulation</small>
                        </div>
                        <div id="timeline-container" style="height: 300px; position: relative;">
                            <svg id="branches-svg" width="100%" height="100%" style="position: absolute; top: 0; left: 0;"></svg>
                            <canvas id="timeline-chart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Initialize charts and UI elements
        let identityChart, timelineChart;
        let futureHistory = [];

        // Initialize identity chart
        function initIdentityChart() {
            const ctx = document.getElementById('identity-chart').getContext('2d');

            // Use two datasets to group related traits
            identityChart = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: [
                        'Openness', 'Conscientiousness', 'Extraversion',
                        'Agreeableness', 'Neuroticism (-))', 'Optimism',
                        'Adaptability', 'Risk Tolerance', 'Analytical',
                        'Creativity', 'Helpfulness'
                    ],
                    datasets: [{
                        label: 'Personality Profile',
                        data: [0.7, 0.6, 0.5, 0.8, 0.7, 0.6, 0.7, 0.4, 0.6, 0.5, 0.8],
                        backgroundColor: 'rgba(54, 162, 235, 0.2)',
                        borderColor: 'rgba(54, 162, 235, 1)',
                        pointBackgroundColor: 'rgba(54, 162, 235, 1)',
                        pointBorderColor: '#fff',
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: 'rgba(54, 162, 235, 1)'
                    }]
                },
                options: {
                    scales: {
                        r: {
                            angleLines: {
                                display: true
                            },
                            suggestedMin: 0,
                            suggestedMax: 1
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const trait = context.label;
                                    const value = context.raw;

                                    // For neuroticism, we invert the display since it's negative
                                    if (trait.includes('Neuroticism')) {
                                        return `${trait}: ${value.toFixed(2)} (Lower = more stable)`;
                                    }

                                    // Descriptions for each trait
                                    const descriptions = {
                                        'Openness': 'Curiosity and openness to new ideas',
                                        'Conscientiousness': 'Organization and reliability',
                                        'Extraversion': 'Sociability and assertiveness',
                                        'Agreeableness': 'Empathy and cooperation',
                                        'Neuroticism (-)': 'Emotional stability',
                                        'Optimism': 'Positive outlook on future',
                                        'Adaptability': 'Flexibility in changing situations',
                                        'Risk Tolerance': 'Comfort with uncertainty',
                                        'Analytical': 'Logical thinking ability',
                                        'Creativity': 'Novel idea generation',
                                        'Helpfulness': 'Desire to assist others'
                                    };

                                    return [`${trait}: ${value.toFixed(2)}`, descriptions[trait] || ''];
                                }
                            }
                        }
                    }
                }
            });
        }

        // Initialize timeline chart with branching visualization
        function initTimelineChart() {
            const ctx = document.getElementById('timeline-chart').getContext('2d');

            // Empty data initially
            timelineChart = new Chart(ctx, {
                type: 'bubble',
                data: {
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 1000  // Slow down animations for better visibility
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: {
                                display: true,
                                text: 'Time'
                            },
                            ticks: {
                                callback: function(value) {
                                    // Convert to minutes:seconds
                                    const minutes = Math.floor(value / 60);
                                    const seconds = Math.floor(value % 60);
                                    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
                                }
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Branching Paths'
                            },
                            min: 0,
                            max: 1,
                            ticks: {
                                display: false
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const item = context.raw;
                                    return [
                                        `Future: ${item.label || 'Unknown'}`,
                                        `Probability: ${(item.probability * 100).toFixed(1)}%`,
                                        `Goal: ${item.goal || 'None'}`
                                    ];
                                }
                            }
                        }
                    }
                }
            });
        }

        // Update the identity visualization
        function updateIdentity(identity) {
            if (!identity) return;

            // For neuroticism, we display the inverse (1 - value) since it's a "negative" trait
            // This way, higher on the chart = better (more emotional stability)
            const neuroticismInverse = 1 - (identity.neuroticism || 0);

            identityChart.data.datasets[0].data = [
                identity.openness || 0,
                identity.conscientiousness || 0,
                identity.extraversion || 0,
                identity.agreeableness || 0,
                neuroticismInverse,
                identity.optimism || 0,
                identity.adaptability || 0,
                identity.risk_tolerance || 0,
                identity.analytical || 0,
                identity.creativity || 0,
                identity.helpfulness || 0
            ];
            identityChart.update();
        }

        // Update the time perception display
        function updateTimePerception(timePerception) {
            if (!timePerception) return;

            // Update text displays
            document.getElementById('conversation-duration').textContent =
                formatDuration(timePerception.conversation_duration);

            document.getElementById('interaction-frequency').textContent =
                `${timePerception.interaction_frequency.toFixed(1)}s`;

            // Update progress bars
            document.getElementById('time-pressure-bar').style.width =
                `${timePerception.perceived_time_pressure * 100}%`;

            document.getElementById('future-orientation-bar').style.width =
                `${timePerception.future_orientation * 100}%`;
        }

        // Format duration in seconds to minutes:seconds
        function formatDuration(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        // Update the futures visualization
        function updateFutures(futures, timestamp) {
            if (!futures || futures.length === 0) return;

            const container = document.getElementById('futures-container');
            container.innerHTML = '';

            // Update timestamp if provided
            if (timestamp) {
                document.getElementById('futures-timestamp').textContent =
                    `Last updated: ${new Date(timestamp * 1000).toLocaleTimeString()}`;
            }

            // Create future elements
            futures.forEach((future, index) => {
                const futureElement = document.createElement('div');

                // Add valence-based class if available
                let valenceClass = '';
                if (future.valence === 'positive') {
                    valenceClass = 'positive-future';
                } else if (future.valence === 'negative') {
                    valenceClass = 'negative-future';
                } else if (future.valence === 'neutral') {
                    valenceClass = 'neutral-future';
                }

                futureElement.className = `future-item mb-4 ${index < 2 ? 'preferred' : ''} ${valenceClass}`;

                // Calculate probability percentage and width
                const probabilityPercent = (future.probability * 100).toFixed(1);

                // Create a label for the valence if available
                let valenceLabel = '';
                if (future.valence) {
                    const valenceColors = {
                        'positive': 'success',
                        'neutral': 'secondary',
                        'negative': 'danger'
                    };
                    const color = valenceColors[future.valence] || 'secondary';
                    valenceLabel = `<span class="badge bg-${color} me-2">${future.valence}</span>`;
                }

                // Content for different timeframes
                let timeframeContent = '';

                if (future.short_term || future.mid_term || future.long_term) {
                    timeframeContent = `
                        <div class="timeframes mt-2">
                            ${future.short_term ? `<p class="timeframe short-term mb-1"><strong>Short-term:</strong> ${future.short_term}</p>` : ''}
                            ${future.mid_term ? `<p class="timeframe mid-term mb-1"><strong>Mid-term:</strong> ${future.mid_term}</p>` : ''}
                            ${future.long_term ? `<p class="timeframe long-term mb-1"><strong>Long-term:</strong> ${future.long_term}</p>` : ''}
                        </div>
                    `;
                } else {
                    // Fallback for old format
                    timeframeContent = `<p class="future-description mb-1">${future.description || ''}</p>`;
                }

                futureElement.innerHTML = `
                    <div class="d-flex justify-content-between align-items-center mb-1">
                        <div>
                            <strong class="future-title">Future ${index + 1}</strong>
                            ${valenceLabel}
                        </div>
                        <span class="probability-badge">${probabilityPercent}%</span>
                    </div>
                    ${timeframeContent}
                    <div class="progress" style="height: 4px;">
                        <div class="progress-bar ${future.valence === 'negative' ? 'bg-danger' : future.valence === 'positive' ? 'bg-success' : ''}"
                            role="progressbar"
                            style="width: ${probabilityPercent}%"
                            aria-valuenow="${probabilityPercent}" aria-valuemin="0" aria-valuemax="100"></div>
                    </div>
                    <small class="future-goal d-block mt-1"><strong>Goal:</strong> ${future.goal || 'None'}</small>
                `;

                container.appendChild(futureElement);
            });
        }

        // Update the preferred futures display
        function updatePreferredFutures(preferredFutures) {
            if (!preferredFutures || preferredFutures.length === 0) {
                document.getElementById('preferred-futures-container').innerHTML =
                    '<p class="text-center text-muted">No preferred futures yet...</p>';
                return;
            }

            const container = document.getElementById('preferred-futures-container');
            container.innerHTML = '';

            preferredFutures.forEach((future, index) => {
                const futureElement = document.createElement('div');
                futureElement.className = 'preferred-future-item mb-3';

                // Include alignment score if available
                const alignmentDisplay = future.alignment ?
                    `<span class="alignment-badge ms-2" title="Alignment with identity">
                        Alignment: ${future.alignment.toFixed(2)}
                    </span>` : '';

                // Content for different timeframes
                let timeframeContent = '';

                if (future.short_term || future.mid_term || future.long_term) {
                    timeframeContent = `
                        <div class="timeframes mt-2">
                            ${future.short_term ? `<p class="timeframe short-term mb-1"><strong>Short-term:</strong> ${future.short_term}</p>` : ''}
                            ${future.mid_term ? `<p class="timeframe mid-term mb-1"><strong>Mid-term:</strong> ${future.mid_term}</p>` : ''}
                            ${future.long_term ? `<p class="timeframe long-term mb-1"><strong>Long-term:</strong> ${future.long_term}</p>` : ''}
                        </div>
                    `;
                } else if (future.description) {
                    // Fallback for old format
                    timeframeContent = `<p class="future-description mb-1">${future.description}</p>`;
                }

                // Create valence label if available
                let valenceLabel = '';
                if (future.valence) {
                    const valenceColors = {
                        'positive': 'success',
                        'neutral': 'secondary',
                        'negative': 'danger'
                    };
                    const color = valenceColors[future.valence] || 'secondary';
                    valenceLabel = `<span class="badge bg-${color} me-2">${future.valence}</span>`;
                }

                futureElement.innerHTML = `
                    <div class="d-flex justify-content-between align-items-center mb-1">
                        <div>
                            <strong class="future-title">Preferred Path ${index + 1}</strong>
                            ${valenceLabel}
                        </div>
                        <div>
                            <span class="probability-badge">${(future.probability * 100).toFixed(1)}%</span>
                            ${alignmentDisplay}
                        </div>
                    </div>
                    ${timeframeContent}
                    <div class="progress" style="height: 6px;">
                        <div class="progress-bar bg-success" role="progressbar"
                            style="width: ${future.probability * 100}%"
                            aria-valuenow="${future.probability * 100}" aria-valuemin="0" aria-valuemax="100"></div>
                    </div>
                    <small class="future-goal d-block mt-1"><strong>Goal:</strong> ${future.goal || 'None'}</small>
                `;

                container.appendChild(futureElement);
            });
        }

        // Update past preferred futures display
        function updatePastPreferredFutures(preferredHistory) {
            if (!preferredHistory || preferredHistory.length === 0) {
                return;
            }

            const container = document.getElementById('past-futures-container');
            if (!container) return;

            container.innerHTML = '';

            // Process history in reverse order (newest first)
            const recentHistory = preferredHistory.slice(-5).reverse();

            recentHistory.forEach((historyEntry, historyIndex) => {
                const timestamp = historyEntry.formatted_time;
                const futures = historyEntry.futures;

                if (!futures || futures.length === 0) return;

                // Create a timestamp header for this history entry
                const timeHeader = document.createElement('div');
                timeHeader.className = 'history-timestamp mb-2 mt-2';
                timeHeader.innerHTML = `<strong>${timestamp}</strong>`;
                container.appendChild(timeHeader);

                // Add each future in this history entry
                futures.forEach((future, index) => {
                    const pastFutureElement = document.createElement('div');
                    pastFutureElement.className = 'past-future-item mb-2';

                    // Get preference score
                    const preferenceScore = future.preference_score || 0;

                    // Get description based on what's available
                    let description = "";
                    if (future.short_term) {
                        description = future.short_term;
                    } else if (future.description) {
                        description = future.description;
                    } else {
                        description = future.goal || "Unknown future";
                    }

                    // Create HTML for this past future
                    pastFutureElement.innerHTML = `
                        <div class="d-flex justify-content-between align-items-center">
                            <span class="past-future-desc">${description}</span>
                            <span class="preference-badge" title="Preference score">
                                ${preferenceScore.toFixed(2)}
                            </span>
                        </div>
                        <div class="progress mt-1" style="height: 3px;">
                            <div class="progress-bar bg-info" role="progressbar"
                                style="width: ${preferenceScore * 100}%"
                                aria-valuenow="${preferenceScore * 100}" aria-valuemin="0" aria-valuemax="100">
                            </div>
                        </div>
                    `;

                    container.appendChild(pastFutureElement);
                });

                // Add a separator if not the last entry
                if (historyIndex < recentHistory.length - 1) {
                    const separator = document.createElement('hr');
                    separator.className = 'my-2';
                    container.appendChild(separator);
                }
            });
        }

        // Update the timeline visualization with branching paths
        function updateTimeline(futureHistory, terminatedFutures) {
            if (!futureHistory || futureHistory.length === 0) return;

            // Store the history
            window.futureHistory = futureHistory;

            // Calculate start time (for x-axis)
            const startTime = futureHistory[0].time;

            // Prepare datasets - one for each unique future description
            const uniqueFutures = new Map();
            let futureIndex = 0;

            // Track all data points for branching visualization
            const allDataPoints = [];

            // Process each snapshot in the history
            futureHistory.forEach((snapshot, snapshotIndex) => {
                const relativeTime = snapshot.time - startTime;

                // Assign consistent y-positions to futures within each snapshot
                const snapshotFutures = snapshot.futures.map(f => {
                    // Use appropriate property based on what's available
                    if (f.short_term) return f.short_term;
                    if (f.description) return f.description;
                    return f.goal || "unknown";
                });

                const yPositions = {};

                // Distribute futures evenly in y space
                snapshotFutures.forEach((desc, i) => {
                    const spacing = 0.8 / (snapshotFutures.length + 1);
                    yPositions[desc] = 0.1 + spacing * (i + 1);
                });

                snapshot.futures.forEach(future => {
                    // Determine key content based on what's available
                    const description = future.short_term || future.description || future.goal || "unknown";

                    // Create a unique key for this future
                    let key = description;
                    if (!uniqueFutures.has(key)) {
                        // Choose color based on valence if available
                        let color;
                        if (future.valence === 'positive') {
                            color = 'rgba(40, 167, 69, 0.7)'; // Green for positive
                        } else if (future.valence === 'negative') {
                            color = 'rgba(220, 53, 69, 0.7)'; // Red for negative
                        } else if (future.valence === 'neutral') {
                            color = 'rgba(108, 117, 125, 0.7)'; // Gray for neutral
                        } else {
                            // Default colors if no valence
                            color = getColorForIndex(futureIndex);
                        }

                        uniqueFutures.set(key, {
                            label: description,
                            data: [],
                            backgroundColor: color,
                            borderColor: getColorForIndex(futureIndex, true),
                            borderWidth: 1,
                            borderDash: future.termination_time ? [5, 5] : [] // Dashed line for terminated futures
                        });
                        futureIndex++;
                    }

                    // Get consistent y position
                    const yPos = yPositions[description] || Math.random() * 0.8 + 0.1;

                    // Add data point
                    const dataPoint = {
                        x: relativeTime,
                        y: yPos,
                        r: future.probability * 20 + 5, // Size based on probability
                        probability: future.probability,
                        label: description.length > 30 ? description.substring(0, 30) + '...' : description,
                        goal: future.goal,
                        valence: future.valence,
                        realism: future.realism,
                        description: description,
                        snapshotIndex: snapshotIndex,
                        futureIndex: uniqueFutures.size - 1,
                        color: uniqueFutures.get(key).backgroundColor,
                        dying: future.dying || false,
                        terminated: future.terminated || false
                    };

                    uniqueFutures.get(key).data.push(dataPoint);
                    allDataPoints.push(dataPoint);
                });
            });

            // Add terminated futures to visualization
            if (terminatedFutures && terminatedFutures.length > 0) {
                terminatedFutures.forEach(future => {
                    const description = future.short_term || future.description || future.goal || "unknown";
                    const key = description;

                    // Skip if we already have this future
                    if (uniqueFutures.has(key)) return;

                    // Create dataset for terminated future
                    let color;
                    if (future.valence === 'positive') {
                        color = 'rgba(40, 167, 69, 0.3)'; // Faded green
                    } else if (future.valence === 'negative') {
                        color = 'rgba(220, 53, 69, 0.3)'; // Faded red
                    } else {
                        color = 'rgba(108, 117, 125, 0.3)'; // Faded gray
                    }

                    uniqueFutures.set(key, {
                        label: description,
                        data: [],
                        backgroundColor: color,
                        borderColor: 'rgba(200, 200, 200, 0.5)',
                        borderWidth: 1,
                        borderDash: [5, 5] // Dashed line for terminated futures
                    });

                    // Calculate relative time
                    const relativeTime = future.termination_time - startTime;

                    // Find a good y position
                    const yPos = Math.random() * 0.8 + 0.1;

                    // Add data point
                    const dataPoint = {
                        x: relativeTime,
                        y: yPos,
                        r: future.probability * 10 + 3, // Smaller size for terminated futures
                        probability: future.probability,
                        label: description.length > 30 ? description.substring(0, 30) + '...' : description,
                        goal: future.goal,
                        description: description,
                        snapshotIndex: -1, // Special index for terminated
                        futureIndex: uniqueFutures.size - 1,
                        color: color,
                        terminated: true
                    };

                    uniqueFutures.get(key).data.push(dataPoint);
                    allDataPoints.push(dataPoint);
                });
            }

            // Update chart with new datasets
            timelineChart.data.datasets = Array.from(uniqueFutures.values());
            timelineChart.update();

            // Draw branching lines using SVG
            drawBranchingLines(allDataPoints, startTime);
        }

        // Draw branching connection lines between futures
        function drawBranchingLines(dataPoints, startTime) {
            // Get SVG element
            const svg = document.getElementById('branches-svg');
            svg.innerHTML = ''; // Clear previous lines

            // Get container dimensions
            const container = document.getElementById('timeline-container');
            const rect = container.getBoundingClientRect();

            // Group by snapshot
            const pointsBySnapshot = {};
            dataPoints.forEach(point => {
                // Skip terminated points for connections
                if (point.terminated) return;

                if (!pointsBySnapshot[point.snapshotIndex]) {
                    pointsBySnapshot[point.snapshotIndex] = [];
                }
                pointsBySnapshot[point.snapshotIndex].push(point);
            });

            // Function to get chart coordinates
            function getChartPosition(x, y) {
                const xScale = timelineChart.scales.x;
                const yScale = timelineChart.scales.y;

                return {
                    x: xScale.getPixelForValue(x),
                    y: yScale.getPixelForValue(y)
                };
            }

            // Draw connections between futures in consecutive snapshots
            const snapshots = Object.keys(pointsBySnapshot).sort((a, b) => a - b);

            for (let i = 0; i < snapshots.length - 1; i++) {
                const currentPoints = pointsBySnapshot[snapshots[i]];
                const nextPoints = pointsBySnapshot[snapshots[i+1]];

                // Draw connections between points
                currentPoints.forEach(source => {
                    // Skip dying points as sources for new connections
                    if (source.dying) return;

                    nextPoints.forEach(target => {
                        // Determine if these futures should be connected
                        // Connect if they share similar descriptions or goals
                        const descriptionSimilarity = calculateSimilarity(
                            source.description,
                            target.description
                        );

                        // Get similarity in goals if available
                        const goalSimilarity = (source.goal && target.goal) ?
                            calculateSimilarity(source.goal, target.goal) : 0;

                        // Get similarity in valence if available
                        const valenceSimilarity = (source.valence && target.valence &&
                                                  source.valence === target.valence) ? 0.5 : 0;

                        // Combined similarity score
                        const totalSimilarity = Math.max(
                            descriptionSimilarity,
                            goalSimilarity * 0.8,  // Goal similarity is weighted slightly less
                            valenceSimilarity
                        );

                        // Only connect if similarity is above threshold
                        if (totalSimilarity > 0.3) {
                            const sourcePos = getChartPosition(source.x, source.y);
                            const targetPos = getChartPosition(target.x, target.y);

                            // Create line with curve
                            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

                            // Calculate control points for curve
                            const dx = targetPos.x - sourcePos.x;
                            const midX = sourcePos.x + dx * 0.5;

                            // Bezier curve
                            const d = `M ${sourcePos.x} ${sourcePos.y}
                                      C ${midX} ${sourcePos.y},
                                        ${midX} ${targetPos.y},
                                        ${targetPos.x} ${targetPos.y}`;

                            // Set attributes
                            path.setAttribute('d', d);
                            path.setAttribute('fill', 'none');

                            // Line thickness based on probability
                            const lineWeight = Math.max(1, Math.min(4,
                                (source.probability + target.probability) * 5)
                            );

                            // Line opacity based on similarity
                            const opacity = Math.max(0.2, Math.min(0.7, totalSimilarity));

                            // Color based on source
                            let strokeColor = source.color;

                            // Special styling for dying paths
                            if (target.dying) {
                                path.setAttribute('stroke-dasharray', '5,5');
                                strokeColor = 'rgba(150, 150, 150, 0.5)';  // Fade color for dying paths
                            }

                            path.setAttribute('stroke-width', lineWeight);
                            path.setAttribute('stroke', strokeColor);
                            path.setAttribute('stroke-opacity', opacity);

                            // Add line
                            svg.appendChild(path);
                        }
                    });
                });
            }

            // Draw termination markers for dying futures
            dataPoints.forEach(point => {
                if (point.dying || point.terminated) {
                    const pos = getChartPosition(point.x, point.y);

                    // Create X marker for terminating path
                    const terminationGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');

                    // First line of X
                    const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line1.setAttribute('x1', pos.x - 8);
                    line1.setAttribute('y1', pos.y - 8);
                    line1.setAttribute('x2', pos.x + 8);
                    line1.setAttribute('y2', pos.y + 8);
                    line1.setAttribute('stroke', 'rgba(200, 50, 50, 0.7)');
                    line1.setAttribute('stroke-width', 2);

                    // Second line of X
                    const line2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line2.setAttribute('x1', pos.x + 8);
                    line2.setAttribute('y1', pos.y - 8);
                    line2.setAttribute('x2', pos.x - 8);
                    line2.setAttribute('y2', pos.y + 8);
                    line2.setAttribute('stroke', 'rgba(200, 50, 50, 0.7)');
                    line2.setAttribute('stroke-width', 2);

                    terminationGroup.appendChild(line1);
                    terminationGroup.appendChild(line2);
                    svg.appendChild(terminationGroup);
                }
            });
        }

        // Get a color based on index for the timeline
        function getColorForIndex(index, isBorder = false) {
            const colors = [
                'rgba(54, 162, 235, 0.6)', // Blue
                'rgba(255, 99, 132, 0.6)', // Red
                'rgba(75, 192, 192, 0.6)', // Green
                'rgba(255, 206, 86, 0.6)', // Yellow
                'rgba(153, 102, 255, 0.6)', // Purple
                'rgba(255, 159, 64, 0.6)', // Orange
                'rgba(199, 199, 199, 0.6)' // Gray
            ];

            const borderColors = [
                'rgba(54, 162, 235, 1)',
                'rgba(255, 99, 132, 1)',
                'rgba(75, 192, 192, 1)',
                'rgba(255, 206, 86, 1)',
                'rgba(153, 102, 255, 1)',
                'rgba(255, 159, 64, 1)',
                'rgba(199, 199, 199, 1)'
            ];

            const colorIndex = index % colors.length;
            return isBorder ? borderColors[colorIndex] : colors[colorIndex];
        }

        // Calculate similarity between two strings (basic implementation)
        function calculateSimilarity(str1, str2) {
            // Convert to lowercase
            const a = str1.toLowerCase();
            const b = str2.toLowerCase();

            // Count matching words
            const wordsA = a.split(/\s+/);
            const wordsB = b.split(/\s+/);

            let matches = 0;
            wordsA.forEach(word => {
                if (word.length > 3 && wordsB.includes(word)) {
                    matches++;
                }
            });

            const totalWords = Math.max(wordsA.length, wordsB.length);
            return matches / totalWords;
        }

        // Add a message to the chat
        function addMessage(message, sender) {
            const chatContainer = document.getElementById('chat-container');
            const messageElement = document.createElement('div');
            messageElement.className = `message ${sender}-message mb-3`;

            messageElement.innerHTML = `
                <div class="message-content p-3">
                    <p class="mb-0">${message}</p>
                </div>
            `;

            chatContainer.appendChild(messageElement);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        // Submit a question to the AI
        async function askQuestion(question) {
            try {
                addMessage(question, 'user');

                const response = await fetch('/ask', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ question })
                });

                if (!response.ok) {
                    throw new Error('Failed to get response');
                }

                const data = await response.json();
                addMessage(data.response, 'ai');

                // Update visualizations with the returned data
                if (data.identity) {
                    updateIdentity(data.identity);
                }

                if (data.futures) {
                    updateFutures(data.futures);
                }

                if (data.preferred_futures) {
                    updatePreferredFutures(data.preferred_futures);
                }

                // Update full state from the server
                fetchState();

            } catch (error) {
                console.error('Error:', error);
                addMessage('I\'m having trouble processing that question.', 'ai');
            }
        }

        // Fetch the current state from the server
        async function fetchState() {
            try {
                const response = await fetch('/state');
                if (!response.ok) {
                    throw new Error('Failed to fetch state');
                }

                const data = await response.json();

                // Update all visualizations
                updateIdentity(data.identity);
                updateTimePerception(data.time_perception);
                updateFutures(data.futures);
                updatePreferredFutures(data.preferred_futures);
                updateTimeline(data.future_history, data.terminated_futures);

                if (data.preferred_futures_history) {
                    updatePastPreferredFutures(data.preferred_futures_history);
                }

            } catch (error) {
                console.error('Error fetching state:', error);
            }
        }

        // Reset the AI
        async function resetAI() {
            try {
                const response = await fetch('/reset', {
                    method: 'POST'
                });

                if (!response.ok) {
                    throw new Error('Failed to reset AI');
                }

                // Clear chat
                document.getElementById('chat-container').innerHTML = '';

                // Add reset message
                addMessage('I\'ve been reset and am simulating new possible futures for our conversation.', 'ai');

                // Fetch updated state
                fetchState();

            } catch (error) {
                console.error('Error resetting AI:', error);
            }
        }

        // Randomize AI identity values
        async function randomizeIdentity() {
            try {
                const response = await fetch('/randomize', {
                    method: 'POST'
                });

                if (!response.ok) {
                    throw new Error('Failed to randomize identity');
                }

                const data = await response.json();

                // Update identity chart immediately
                if (data.identity) {
                    updateIdentity(data.identity);
                }

                // Add message about identity change
                addMessage('My identity values have been randomized. This will affect which future paths I find most meaningful.', 'ai');

                // Fetch updated state to get new futures
                fetchState();

            } catch (error) {
                console.error('Error randomizing identity:', error);
            }
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize charts
            initIdentityChart();
            initTimelineChart();

            // Form submission
            document.getElementById('question-form').addEventListener('submit', event => {
                event.preventDefault();
                const input = document.getElementById('question-input');
                const question = input.value.trim();

                if (question) {
                    askQuestion(question);
                    input.value = '';
                }
            });

            // Reset button
            document.getElementById('reset-btn').addEventListener('click', resetAI);

            // Randomize identity button
            document.getElementById('randomize-btn').addEventListener('click', randomizeIdentity);

            // Theme toggle
            document.getElementById('theme-toggle').addEventListener('click', () => {
                document.body.classList.toggle('dark-theme');
                document.body.classList.toggle('light-theme');
                localStorage.setItem('theme', document.body.classList.contains('dark-theme') ? 'dark' : 'light');
            });

            // Load saved theme preference
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'dark') {
                document.body.classList.remove('light-theme');
                document.body.classList.add('dark-theme');
            }

            // Fetch initial state
            fetchState();

            // Set up periodic state updates
            setInterval(fetchState, 3000);  // Poll every 3 seconds instead of 5

            // Add welcome message
            addMessage('Hey there! How are you doing today?', 'ai');
        });
    </script>
    <script src="{{ url_for('static', filename='js/dark-theme.js') }}"></script>
</body>
</html>